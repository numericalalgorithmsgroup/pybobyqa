<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Using Py-BOBYQA &mdash; Py-BOBYQA v1.5.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=e0a75244"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Advanced Usage" href="advanced.html" />
    <link rel="prev" title="Overview" href="info.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Py-BOBYQA
          </a>
              <div class="version">
                1.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing Py-BOBYQA</a></li>
<li class="toctree-l1"><a class="reference internal" href="info.html">Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using Py-BOBYQA</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#nonlinear-minimization">Nonlinear Minimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-use-py-bobyqa">How to use Py-BOBYQA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-simple-example">A Simple Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-bounds-and-more-output">Adding Bounds and More Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-general-convex-constraints">Adding General Convex Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-noisy-objective-evaluation">Example: Noisy Objective Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-global-optimization">Example: Global Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="diagnostic.html">Diagnostic Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Version History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Py-BOBYQA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Using Py-BOBYQA</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/userguide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="using-py-bobyqa">
<h1>Using Py-BOBYQA<a class="headerlink" href="#using-py-bobyqa" title="Link to this heading"></a></h1>
<p>This section describes the main interface to Py-BOBYQA and how to use it.</p>
<section id="nonlinear-minimization">
<h2>Nonlinear Minimization<a class="headerlink" href="#nonlinear-minimization" title="Link to this heading"></a></h2>
<p>Py-BOBYQA is designed to solve the local optimization problem</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_{x\in\mathbb{R}^n}  &amp;\quad  f(x) \\
\text{s.t.} &amp;\quad  a \leq x \leq b\\
&amp;\quad x \in C := C_1 \cap \cdots \cap C_n, \quad \text{all $C_i$ convex}\end{split}\]</div>
<p>where the bound constraints <span class="math notranslate nohighlight">\(a \leq x \leq b\)</span> and general convex constraints <span class="math notranslate nohighlight">\(x \in C\)</span> are optional.
The upper and lower bounds on the variables are non-relaxable (i.e. Py-BOBYQA will never ask to evaluate a point outside the bounds).
The general convex constraints are also non-relaxable, but they may be slightly violated at some points from rounding errors.
The objective function <span class="math notranslate nohighlight">\(f(x)\)</span> is usually nonlinear and nonquadratic.
If you know your objective is linear or quadratic, you should consider a solver designed for such functions (see <a class="reference external" href="https://neos-guide.org/Optimization-Guide">here</a> for details).</p>
<p>Py-BOBYQA iteratively constructs an interpolation-based model for the objective, and determines a step using a trust-region framework.
For an in-depth technical description of the algorithm see the paper <a class="reference internal" href="#cfmr2018" id="id1"><span>[CFMR2018]</span></a>, and for the global optimization heuristic, see <a class="reference internal" href="#cro2022" id="id2"><span>[CRO2022]</span></a>.
For details about how Py-BOBYQA handles general convex constraints, see <a class="reference internal" href="#r2024" id="id3"><span>[R2024]</span></a>.</p>
</section>
<section id="how-to-use-py-bobyqa">
<h2>How to use Py-BOBYQA<a class="headerlink" href="#how-to-use-py-bobyqa" title="Link to this heading"></a></h2>
<p>The main interface to Py-BOBYQA is via the function <code class="code docutils literal notranslate"><span class="pre">solve</span></code></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">objfun</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The input <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> is a Python function which takes an input <span class="math notranslate nohighlight">\(x\in\mathbb{R}^n\)</span> and returns the objective value <span class="math notranslate nohighlight">\(f(x)\in\mathbb{R}\)</span>. The input of <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> must be one-dimensional NumPy arrays (i.e. with <code class="code docutils literal notranslate"><span class="pre">x.shape</span> <span class="pre">==</span> <span class="pre">(n,)</span></code>) and the output must be a single Float.</p>
<p>The input <code class="code docutils literal notranslate"><span class="pre">x0</span></code> is the starting point for the solver, and (where possible) should be set to be the best available estimate of the true solution <span class="math notranslate nohighlight">\(x_{min}\in\mathbb{R}^n\)</span>. It should be specified as a one-dimensional NumPy array (i.e. with <code class="code docutils literal notranslate"><span class="pre">x0.shape</span> <span class="pre">==</span> <span class="pre">(n,)</span></code>).
As Py-BOBYQA is a local solver, providing different values for <code class="code docutils literal notranslate"><span class="pre">x0</span></code> may cause it to return different solutions, with possibly different objective values.</p>
<p>The output of <code class="code docutils literal notranslate"><span class="pre">pybobyqa.solve</span></code> is an object containing:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.x</span></code> - an estimate of the solution, <span class="math notranslate nohighlight">\(x_{min}\in\mathbb{R}^n\)</span>, a one-dimensional NumPy array.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.f</span></code> - the objective value at the calculated solution, <span class="math notranslate nohighlight">\(f(x_{min})\)</span>, a Float.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.gradient</span></code> - an estimate of the gradient vector of first derivatives of the objective, <span class="math notranslate nohighlight">\(g_i \approx \partial f(x_{min})/\partial x_i\)</span>, a NumPy array of length <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.hessian</span></code> - an estimate of the Hessian matrix of second derivatives of the objective, <span class="math notranslate nohighlight">\(H_{i,j} \approx \partial^2 f(x_{min})/\partial x_i \partial x_j\)</span>, a NumPy array of size <span class="math notranslate nohighlight">\(n\times n\)</span>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.nf</span></code> - the number of evaluations of <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> that the algorithm needed, an Integer.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.nx</span></code> - the number of points <span class="math notranslate nohighlight">\(x\)</span> at which <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> was evaluated, an Integer. This may be different to <code class="code docutils literal notranslate"><span class="pre">soln.nf</span></code> if sample averaging is used.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.nruns</span></code> - the number of runs performed by Py-BOBYQA (more than 1 if using multiple restarts), an Integer.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.flag</span></code> - an exit flag, which can take one of several values (listed below), an Integer.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.msg</span></code> - a description of why the algorithm finished, a String.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.diagnostic_info</span></code> - a table of diagnostic information showing the progress of the solver, a Pandas DataFrame.</p></li>
</ul>
<p>The possible values of <code class="code docutils literal notranslate"><span class="pre">soln.flag</span></code> are defined by the following variables:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_SUCCESS</span></code> - Py-BOBYQA terminated successfully (the objective value or trust region radius are sufficiently small).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_MAXFUN_WARNING</span></code> - maximum allowed objective evaluations reached. This is the most likely return value when using multiple restarts.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_SLOW_WARNING</span></code> - maximum number of slow iterations reached.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_FALSE_SUCCESS_WARNING</span></code> - Py-BOBYQA reached the maximum number of restarts which decreased the objective, but to a worse value than was found in a previous run.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_INPUT_ERROR</span></code> - error in the inputs.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_TR_INCREASE_ERROR</span></code> - error occurred when solving the trust region subproblem.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">soln.EXIT_LINALG_ERROR</span></code> - linear algebra error, e.g. the interpolation points produced a singular linear system.</p></li>
</ul>
<p>These variables are defined in the <code class="code docutils literal notranslate"><span class="pre">soln</span></code> object, so can be accessed with, for example</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">soln</span><span class="o">.</span><span class="n">flag</span> <span class="o">==</span> <span class="n">soln</span><span class="o">.</span><span class="n">EXIT_SUCCESS</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="optional-arguments">
<h2>Optional Arguments<a class="headerlink" href="#optional-arguments" title="Link to this heading"></a></h2>
<p>The <code class="code docutils literal notranslate"><span class="pre">solve</span></code> function has several optional arguments which the user may provide:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">objfun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">npt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhobeg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhoend</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">objfun_has_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">seek_global_minimum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">scaling_within_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">do_logging</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>These arguments are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">args</span></code> - a tuple of extra arguments passed to the objective function.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">bounds</span></code> - a tuple <code class="code docutils literal notranslate"><span class="pre">(lower,</span> <span class="pre">upper)</span></code> with the vectors <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> of lower and upper bounds on <span class="math notranslate nohighlight">\(x\)</span> (default is <span class="math notranslate nohighlight">\(a_i=-10^{20}\)</span> and <span class="math notranslate nohighlight">\(b_i=10^{20}\)</span>). To set bounds for either <code class="code docutils literal notranslate"><span class="pre">lower</span></code> or <code class="code docutils literal notranslate"><span class="pre">upper</span></code>, but not both, pass a tuple <code class="code docutils literal notranslate"><span class="pre">(lower,</span> <span class="pre">None)</span></code> or <code class="code docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">projections</span></code> - a list of functions defining the Euclidean projections for each general convex constraint <span class="math notranslate nohighlight">\(C_i\)</span>. Each element of the list <code class="code docutils literal notranslate"><span class="pre">projections</span></code> is a function that takes an input vector <span class="math notranslate nohighlight">\(x\)</span> and returns the closest point to <span class="math notranslate nohighlight">\(x\)</span> that is in <span class="math notranslate nohighlight">\(C_i\)</span>. An example of using this is given below.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">npt</span></code> - the number of interpolation points to use (default is <span class="math notranslate nohighlight">\(2n+1\)</span> for a problem with <code class="code docutils literal notranslate"><span class="pre">len(x0)=n</span></code> if <code class="code docutils literal notranslate"><span class="pre">objfun_has_noise=False</span></code>, otherwise it is set to <span class="math notranslate nohighlight">\((n+1)(n+2)/2\)</span>). Py-BOBYQA requires <span class="math notranslate nohighlight">\(n+1 \leq npt \leq (n+1)(n+2)/2\)</span>. Larger values are particularly useful for noisy problems.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">rhobeg</span></code> - the initial value of the trust region radius (default is 0.1 if <code class="code docutils literal notranslate"><span class="pre">scaling_within_bounds=True</span></code>, otherwise <span class="math notranslate nohighlight">\(0.1\max(\|x_0\|_{\infty}, 1)\)</span>).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">rhoend</span></code> - minimum allowed value of trust region radius, which determines when a successful termination occurs (default is <span class="math notranslate nohighlight">\(10^{-8}\)</span>).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">maxfun</span></code> - the maximum number of objective evaluations the algorithm may request (default is <span class="math notranslate nohighlight">\(\min(100(n+1),1000)\)</span>).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">nsamples</span></code> - a Python function <code class="code docutils literal notranslate"><span class="pre">nsamples(delta,</span> <span class="pre">rho,</span> <span class="pre">iter,</span> <span class="pre">nrestarts)</span></code> which returns the number of times to evaluate <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> at a given point. This is only applicable for objectives with stochastic noise, when averaging multiple evaluations at the same point produces a more accurate value. The input parameters are the trust region radius (<code class="code docutils literal notranslate"><span class="pre">delta</span></code>), the lower bound on the trust region radius (<code class="code docutils literal notranslate"><span class="pre">rho</span></code>), how many iterations the algorithm has been running for (<code class="code docutils literal notranslate"><span class="pre">iter</span></code>), and how many restarts have been performed (<code class="code docutils literal notranslate"><span class="pre">nrestarts</span></code>). Default is no averaging (i.e. <code class="code docutils literal notranslate"><span class="pre">nsamples(delta,</span> <span class="pre">rho,</span> <span class="pre">iter,</span> <span class="pre">nrestarts)=1</span></code>).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">user_params</span></code> - a Python dictionary <code class="code docutils literal notranslate"><span class="pre">{'param1':</span> <span class="pre">val1,</span> <span class="pre">'param2':val2,</span> <span class="pre">...}</span></code> of optional parameters. A full list of available options is given in the next section <a class="reference internal" href="advanced.html"><span class="doc">Advanced Usage</span></a>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">objfun_has_noise</span></code> - a flag to indicate whether or not <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> has stochastic noise; i.e. will calling <code class="code docutils literal notranslate"><span class="pre">objfun(x)</span></code> multiple times at the same value of <code class="code docutils literal notranslate"><span class="pre">x</span></code> give different results? This is used to set some sensible default parameters (including using multiple restarts), all of which can be overridden by the values provided in <code class="code docutils literal notranslate"><span class="pre">user_params</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">seek_global_minimum</span></code> - a flag to indicate whether to search for a global minimum, rather than a local minimum. This is used to set some sensible default parameters, all of which can be overridden by the values provided in <code class="code docutils literal notranslate"><span class="pre">user_params</span></code>. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, both upper and lower bounds must be set. Note that Py-BOBYQA only implements a heuristic method, so there are no guarantees it will find a global minimum. However, by using this flag, it is more likely to escape local minima if there are better values nearby. The method used is a multiple restart mechanism, where we repeatedly re-initialize Py-BOBYQA from the best point found so far, but where we use a larger trust reigon radius each time (note: this is different to more common multi-start approach to global optimization).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">scaling_within_bounds</span></code> - a flag to indicate whether the algorithm should internally shift and scale the entries of <code class="code docutils literal notranslate"><span class="pre">x</span></code> so that the bounds become <span class="math notranslate nohighlight">\(0 \leq x \leq 1\)</span>. This is useful is you are setting <code class="code docutils literal notranslate"><span class="pre">bounds</span></code> and the bounds have different orders of magnitude. If <code class="code docutils literal notranslate"><span class="pre">scaling_within_bounds=True</span></code>, the values of <code class="code docutils literal notranslate"><span class="pre">rhobeg</span></code> and <code class="code docutils literal notranslate"><span class="pre">rhoend</span></code> apply to the <em>shifted</em> variables.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">do_logging</span></code> - a flag to indicate whether logging output should be produced. This is not automatically visible unless you use the Python <a class="reference external" href="https://docs.python.org/3/library/logging.html">logging</a> module (see below for simple usage).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">print_progress</span></code> - a flag to indicate whether to print a per-iteration progress log to terminal.</p></li>
</ul>
<p>In general when using optimization software, it is good practice to scale your variables so that moving each by a given amount has approximately the same impact on the objective function.
The <code class="code docutils literal notranslate"><span class="pre">scaling_within_bounds</span></code> flag is designed to provide an easy way to achieve this, if you have set the bounds <code class="code docutils literal notranslate"><span class="pre">lower</span></code> and <code class="code docutils literal notranslate"><span class="pre">upper</span></code>.</p>
</section>
<section id="a-simple-example">
<h2>A Simple Example<a class="headerlink" href="#a-simple-example" title="Link to this heading"></a></h2>
<p>Suppose we wish to minimize the <a class="reference external" href="https://en.wikipedia.org/wiki/Rosenbrock_function">Rosenbrock test function</a>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_{(x_1,x_2)\in\mathbb{R}^2}  &amp;\quad  100(x_2-x_1^2)^2 + (1-x_1)^2 \\\end{split}\]</div>
<p>This function has exactly one local minimum <span class="math notranslate nohighlight">\(f(x_{min})=0\)</span> at <span class="math notranslate nohighlight">\(x_{min}=(1,1)\)</span>. A commonly-used starting point for testing purposes is <span class="math notranslate nohighlight">\(x_0=(-1.2,1)\)</span>. The following script shows how to solve this problem using Py-BOBYQA:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Py-BOBYQA example: minimize the Rosenbrock function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pybobyqa</span>

<span class="c1"># Define the objective function</span>
<span class="k">def</span> <span class="nf">rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># Define the starting point</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

<span class="c1"># Call Py-BOBYQA</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rosenbrock</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

<span class="c1"># Display output</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Note that Py-BOBYQA is a randomized algorithm: in its first phase, it builds an internal approximation to the objective function by sampling it along random directions. In the code above, we set NumPy’s random seed for reproducibility over multiple runs, but this is not required. The output of this script, showing that Py-BOBYQA finds the correct solution, is</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>****** Py-BOBYQA Results ******
Solution xmin = [1. 1.]
Objective value f(xmin) = 1.013856052e-20
Needed 151 objective evaluations (at 151 points)
Approximate gradient = [ 2.35772499e-08 -1.07598803e-08]
Approximate Hessian = [[ 802.00799968 -400.04089119]
 [-400.04089119  199.99228723]]
Exit flag = 0
Success: rho has reached rhoend
******************************
</pre></div>
</div>
</div></blockquote>
<p>This and all following problems can be found in the <a class="reference external" href="https://github.com/numericalalgorithmsgroup/pybobyqa/tree/master/examples">examples</a> directory on the Py-BOBYQA Github page.</p>
</section>
<section id="adding-bounds-and-more-output">
<h2>Adding Bounds and More Output<a class="headerlink" href="#adding-bounds-and-more-output" title="Link to this heading"></a></h2>
<p>We can extend the above script to add constraints. To do this, we can add the lines</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define bound constraints (lower &lt;= x &lt;= upper)</span>
<span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">])</span>
<span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.85</span><span class="p">])</span>

<span class="c1"># Call Py-BOBYQA (with bounds)</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rosenbrock</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">))</span>
</pre></div>
</div>
</div></blockquote>
<p>Py-BOBYQA correctly finds the solution to the constrained problem:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>****** Py-BOBYQA Results ******
Solution xmin = [0.9  0.81]
Objective value f(xmin) = 0.01
Needed 146 objective evaluations (at 146 points)
Approximate gradient = [-2.00000006e-01 -4.74578563e-09]
Approximate Hessian = [[ 649.66398033 -361.03094781]
 [-361.03094781  199.94223213]]
Exit flag = 0
Success: rho has reached rhoend
******************************
</pre></div>
</div>
</div></blockquote>
<p>However, we also get a warning that our starting point was outside of the bounds:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RuntimeWarning: x0 above upper bound, adjusting
</pre></div>
</div>
</div></blockquote>
<p>Py-BOBYQA automatically fixes this, and moves <span class="math notranslate nohighlight">\(x_0\)</span> to a point within the bounds, in this case <span class="math notranslate nohighlight">\(x_0=(-1.2,0.85)\)</span>.</p>
<p>We can also get Py-BOBYQA to print out more detailed information about its progress using the <a class="reference external" href="https://docs.python.org/3/library/logging.html">logging</a> module. To do this, we need to add the following lines:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># ... (call pybobyqa.solve)</span>
</pre></div>
</div>
</div></blockquote>
<p>And we can now see each evaluation of <code class="code docutils literal notranslate"><span class="pre">objfun</span></code>:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Function eval 1 at point 1 has f = 39.65 at x = [-1.2   0.85]
Initialising (coordinate directions)
Function eval 2 at point 2 has f = 14.337296 at x = [-1.08  0.85]
Function eval 3 at point 3 has f = 55.25 at x = [-1.2   0.73]
...
Function eval 145 at point 145 has f = 0.0100000013172792 at x = [0.89999999 0.80999999]
Function eval 146 at point 146 has f = 0.00999999999999993 at x = [0.9  0.81]
Did a total of 1 run(s)
</pre></div>
</div>
</div></blockquote>
<p>If we wanted to save this output to a file, we could replace the above call to <code class="code docutils literal notranslate"><span class="pre">logging.basicConfig()</span></code> with</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;myfile.log&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">filemode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>If you have logging for some parts of your code and you want to deactivate all Py-BOBYQA logging, you can use the optional argument <code class="code docutils literal notranslate"><span class="pre">do_logging=False</span></code> in <code class="code docutils literal notranslate"><span class="pre">pybobyqa.solve()</span></code>.</p>
<p>An alternative option available is to get Py-BOBYQA to print to terminal progress information every iteration, by setting the optional argument <code class="code docutils literal notranslate"><span class="pre">print_progress=True</span></code> in <code class="code docutils literal notranslate"><span class="pre">pybobyqa.solve()</span></code>. If we do this for the above example, we get</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Run  Iter     Obj       Grad     Delta      rho     Evals
  1     1    1.43e+01  1.74e+02  1.20e-01  1.20e-01    5
  1     2    5.57e+00  1.20e+02  3.66e-01  1.20e-01    6
  1     3    5.57e+00  1.20e+02  6.00e-02  1.20e-02    6
...
  1    132   1.00e-02  2.00e-01  1.50e-08  1.00e-08   144
  1    133   1.00e-02  2.00e-01  1.50e-08  1.00e-08   145
</pre></div>
</div>
</div></blockquote>
</section>
<section id="adding-general-convex-constraints">
<h2>Adding General Convex Constraints<a class="headerlink" href="#adding-general-convex-constraints" title="Link to this heading"></a></h2>
<p>We can also add more general convex constraints <span class="math notranslate nohighlight">\(x \in C := C_1 \cap \cdots \cap C_n\)</span> to our problem, where
each <span class="math notranslate nohighlight">\(C_i\)</span> is a convex set. To do this, we need to know the Euclidean projection operator for each <span class="math notranslate nohighlight">\(C_i\)</span>:</p>
<div class="math notranslate nohighlight">
\[\operatorname{proj}_{C_i}(x) := \operatorname{argmin}_{y\in C_i} \|y-x\|_2^2.\]</div>
<p>i.e. given a point <span class="math notranslate nohighlight">\(x\)</span>, return the closest point to <span class="math notranslate nohighlight">\(x\)</span> in the set <span class="math notranslate nohighlight">\(C_i\)</span>.
There are many examples of simple convex sets <span class="math notranslate nohighlight">\(C_i\)</span> for which this function has a known, simple form, such as:</p>
<ul class="simple">
<li><p>Bound constraints (but since Py-BOBYQA supports this directly, it is better to give these explicitly via the <code class="code docutils literal notranslate"><span class="pre">bounds</span></code> input, as above)</p></li>
<li><p>Euclidean ball constraints: <span class="math notranslate nohighlight">\(\|x-c\|_2 \leq r\)</span></p></li>
<li><p>Unit simplex: <span class="math notranslate nohighlight">\(x_i \geq 0\)</span> and <span class="math notranslate nohighlight">\(\sum_{i=1}^{n} x_i \leq 1\)</span></p></li>
<li><p>Linear inequalities: <span class="math notranslate nohighlight">\(a^T x \geq b\)</span></p></li>
</ul>
<p>In Py-BOBYQA, set the input <code class="code docutils literal notranslate"><span class="pre">projections</span></code> to be a list of projection functions, one per <span class="math notranslate nohighlight">\(C_i\)</span>.
Internally, Py-BOBYQA computes the projection onto the intersection of these sets and the bound constraints
using <a class="reference external" href="https://en.wikipedia.org/wiki/Dykstra%27s_projection_algorithm">Dykstra’s projection algorithm</a>.</p>
<p>For the explicit expressions for the above projections, and more examples, see for example <a class="reference external" href="https://proximity-operator.net/indicatorfunctions.html">this online database</a>
or Section 6.4.6 of the textbook <a class="reference internal" href="#b2017" id="id5"><span>[B2017]</span></a>.</p>
<p>As an example, let’s minimize the above Rosenbrock function with different bounds, and with a Euclidean
ball constraint, namely <span class="math notranslate nohighlight">\((x_1-0.5)^2 + (x_2-1)^2 \leq 0.25^2\)</span>.</p>
<p>To do this, we can run</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pybobyqa</span>

<span class="c1"># Define the objective function</span>
<span class="k">def</span> <span class="nf">rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># Define the starting point</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

<span class="c1"># Define bound constraints (lower &lt;= x &lt;= upper)</span>
<span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">])</span>
<span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>

<span class="c1"># Define the ball constraint ||x-center|| &lt;= radius, and its projection operator</span>
<span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="n">radius</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="n">ball_proj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">radius</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">),</span> <span class="n">radius</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">center</span><span class="p">)</span>

<span class="c1"># Call Py-BOBYQA (with bounds and projection operator)</span>
<span class="c1"># Note: it is better to provide bounds explicitly, instead of using the corresponding</span>
<span class="c1">#       projection function</span>
<span class="c1"># Note: input &#39;projections&#39; must be a list of projection functions</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rosenbrock</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">),</span> <span class="n">projections</span><span class="o">=</span><span class="p">[</span><span class="n">ball_proj</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Py-BOBYQA correctly finds the solution to the constrained problem:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>****** Py-BOBYQA Results ******
Solution xmin = [0.70424386 0.85583188]
Objective value f(xmin) = 13.03829114
Needed 25 objective evaluations (at 25 points)
Approximate gradient = [-101.9667031    71.97449424]
Approximate Hessian = [[ 253.11858775 -279.39193327]
 [-279.39193327  201.49725358]]
Exit flag = 0
Success: rho has reached rhoend
******************************
</pre></div>
</div>
</div></blockquote>
<p>Just like for bound constraints, Py-BOBYQA will automatically ensure the starting point is feasible with respect to all constraints (bounds and general convex constraints).</p>
</section>
<section id="example-noisy-objective-evaluation">
<h2>Example: Noisy Objective Evaluation<a class="headerlink" href="#example-noisy-objective-evaluation" title="Link to this heading"></a></h2>
<p>As described in <a class="reference internal" href="info.html"><span class="doc">Overview</span></a>, derivative-free algorithms such as Py-BOBYQA are particularly useful when <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> has noise. Let’s modify the previous example to include random noise in our objective evaluation, and compare it to a derivative-based solver:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Py-BOBYQA example: minimize the noisy Rosenbrock function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pybobyqa</span>

<span class="c1"># Define the objective function</span>
<span class="k">def</span> <span class="nf">rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># Modified objective function: add 1% Gaussian noise</span>
<span class="k">def</span> <span class="nf">rosenbrock_noisy</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Define the starting point</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

<span class="c1"># Set random seed (for reproducibility)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Demonstrate noise in function evaluation:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;objfun(x0) = </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">rosenbrock_noisy</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Call Py-BOBYQA</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rosenbrock_noisy</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

<span class="c1"># Display output</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>

<span class="c1"># Compare with a derivative-based solver</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">opt</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">rosenbrock_noisy</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;** SciPy results **&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solution xmin = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Objective value f(xmin) = </span><span class="si">%.10g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">fun</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Needed </span><span class="si">%g</span><span class="s2"> objective evaluations&quot;</span> <span class="o">%</span> <span class="n">soln</span><span class="o">.</span><span class="n">nfev</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exit flag = </span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">soln</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The output of this is:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Demonstrate noise in function evaluation:
objfun(x0) = 24.6269
objfun(x0) = 24.2968
objfun(x0) = 24.4369
objfun(x0) = 24.7423
objfun(x0) = 24.6519

****** Py-BOBYQA Results ******
Solution xmin = [-1.04327395  1.09935385]
Objective value f(xmin) = 4.080030471
Needed 42 objective evaluations (at 42 points)
Approximate gradient = [-3786376.5065785   5876675.51763198]
Approximate Hessian = [[ 1.32881117e+14 -2.68241358e+14]
 [-2.68241358e+14  6.09785319e+14]]
Exit flag = 0
Success: rho has reached rhoend
******************************


** SciPy results **
Solution xmin = [-1.20013817  0.99992915]
Objective value f(xmin) = 23.86371763
Needed 80 objective evaluations
Exit flag = 2
Desired error not necessarily achieved due to precision loss.
</pre></div>
</div>
</div></blockquote>
<p>Although Py-BOBYQA does not find the true solution (and it cannot produce a good estimate of the objective gradient and Hessian), it still gives a reasonable decrease in the objective. However SciPy’s derivative-based solver, which has no trouble solving the noise-free problem, is unable to make any progress.</p>
<p>As noted above, Py-BOBYQA has an input parameter <code class="code docutils literal notranslate"><span class="pre">objfun_has_noise</span></code> to indicate if <code class="code docutils literal notranslate"><span class="pre">objfun</span></code> has noise in it, which it does in this case. Therefore we can call Py-BOBYQA with</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rosenbrock_noisy</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">objfun_has_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>This time, we find the true solution, and better estimates of the gradient and Hessian:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>****** Py-BOBYQA Results ******
Solution xmin = [1. 1.]
Objective value f(xmin) = 1.237351799e-19
Needed 300 objective evaluations (at 300 points)
Did a total of 5 runs
Approximate gradient = [-2.17072738e-07  9.62304351e-08]
Approximate Hessian = [[ 809.56521044 -400.33737779]
 [-400.33737779  198.36487985]]
Exit flag = 1
Warning (max evals): Objective has been called MAXFUN times
******************************
</pre></div>
</div>
</div></blockquote>
</section>
<section id="example-global-optimization">
<h2>Example: Global Optimization<a class="headerlink" href="#example-global-optimization" title="Link to this heading"></a></h2>
<p>The following example shows how to use the global optimization features of Py-BOBYQA. Here, we try to minimize the Freudenstein and Roth function (problem 2 in J.J. Moré, B.S. Garbow, B.S. and K.E. Hillstrom, Testing Unconstrained Optimization Software, <em>ACM Trans. Math. Software</em> 7:1 (1981), 17-41). This function has two local minima, one of which is global.</p>
<p>Note that Py-BOBYQA only implements a heuristic method, so there are no guarantees it will find a global minimum. However, by using the <code class="code docutils literal notranslate"><span class="pre">seek_global_minimum</span></code> flag, it is more likely to escape local minima if there are better values nearby.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Py-BOBYQA example: globally minimize the Freudenstein and Roth function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pybobyqa</span>

<span class="c1"># Define the objective function</span>
<span class="c1"># This function has a local minimum f = 48.98</span>
<span class="c1"># at x = np.array([11.41, -0.8968])</span>
<span class="c1"># and a global minimum f = 0 at x = np.array([5.0, 4.0])</span>
<span class="k">def</span> <span class="nf">freudenstein_roth</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">13.0</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="mf">5.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">29.0</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">14.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r1</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># Define the starting point</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">5.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.0</span><span class="p">])</span>

<span class="c1"># Define bounds (required for global optimization)</span>
<span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">30.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">30.0</span><span class="p">])</span>
<span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">])</span>

<span class="c1"># Set random seed (for reproducibility)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First run - search for local minimum only&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">freudenstein_roth</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                      <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Second run - search for global minimum&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">soln</span> <span class="o">=</span> <span class="n">pybobyqa</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">freudenstein_roth</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                      <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span>
                      <span class="n">seek_global_minimum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The output of this is:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>First run - search for local minimum only

****** Py-BOBYQA Results ******
Solution xmin = [11.41277902 -0.89680525]
Objective value f(xmin) = 48.98425368
Needed 143 objective evaluations (at 143 points)
Approximate gradient = [-1.64941396e-07  9.69795781e-07]
Approximate Hessian = [[   7.74717421 -104.51102613]
 [-104.51102613 1135.76500421]]
Exit flag = 0
Success: rho has reached rhoend
******************************



Second run - search for global minimum

****** Py-BOBYQA Results ******
Solution xmin = [5. 4.]
Objective value f(xmin) = 3.659891409e-17
Needed 500 objective evaluations (at 500 points)
Did a total of 5 runs
Approximate gradient = [ 8.70038835e-10 -4.64918043e-07]
Approximate Hessian = [[   4.28883646   64.16836253]
 [  64.16836253 3722.93109385]]
Exit flag = 1
Warning (max evals): Objective has been called MAXFUN times
******************************
</pre></div>
</div>
</div></blockquote>
<p>As we can see, the <code class="code docutils literal notranslate"><span class="pre">seek_global_minimum</span></code> flag helped Py-BOBYQA escape the local minimum from the first run, and find the global minimum. More details are given in <a class="reference internal" href="#cro2022" id="id6"><span>[CRO2022]</span></a>.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<div role="list" class="citation-list">
<div class="citation" id="cfmr2018" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">CFMR2018</a><span class="fn-bracket">]</span></span>
<p>Coralia Cartis, Jan Fiala, Benjamin Marteau and Lindon Roberts, <a class="reference external" href="https://doi.org/10.1145/3338517">Improving the Flexibility and Robustness of Model-Based Derivative-Free Optimization Solvers</a>, <em>ACM Transactions on Mathematical Software</em>, 45:3 (2019), pp. 32:1-32:41 [<a class="reference external" href="https://arxiv.org/abs/1804.00154">preprint</a>]</p>
</div>
<div class="citation" id="cro2022" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>CRO2022<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id6">2</a>)</span>
<p>Coralia Cartis, Lindon Roberts and Oliver Sheridan-Methven, <a class="reference external" href="https://doi.org/10.1080/02331934.2021.1883015">Escaping local minima with derivative-free methods: a numerical investigation</a>, <em>Optimization</em>, 71:8 (2022), pp. 2343-2373. [<a class="reference external" href="https://arxiv.org/abs/1812.11343">arXiv preprint: 1812.11343</a>]</p>
</div>
<div class="citation" id="r2024" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">R2024</a><span class="fn-bracket">]</span></span>
<p>Lindon Roberts, <a class="reference external" href="https://arxiv.org/abs/2403.14960">Model Construction for Convex-Constrained Derivative-Free Optimization</a>, <em>arXiv preprint arXiv:2403.14960</em> (2024).</p>
</div>
<div class="citation" id="b2017" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">B2017</a><span class="fn-bracket">]</span></span>
<p>Amir Beck, <a class="reference external" href="https://doi.org/10.1137/1.9781611974997">First-Order Methods in Optimization</a>, SIAM (2017).</p>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="info.html" class="btn btn-neutral float-left" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="advanced.html" class="btn btn-neutral float-right" title="Advanced Usage" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2024, Lindon Roberts.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>