%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Py-BOBYQA Documentation}
\date{16 September 2024}
\release{1.5.0}
\author{Lindon Roberts}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{Release:} 1.5.0

\sphinxAtStartPar
\sphinxstylestrong{Date:} 16 September 2024

\sphinxAtStartPar
\sphinxstylestrong{Author:} \sphinxhref{mailto:lindon.roberts@sydney.edu.au}{Lindon Roberts}

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is a flexible package for finding local solutions to nonlinear, nonconvex minimization problems (with optional bound and other convex constraints), without requiring any derivatives of the objective. Py\sphinxhyphen{}BOBYQA is a Python implementation of the \sphinxhref{http://mat.uc.pt/~zhang/software.html\#powell\_software}{BOBYQA} solver by Powell (documentation \sphinxhref{http://www.damtp.cam.ac.uk/user/na/NA\_papers/NA2009\_06.pdf}{here}). It is particularly useful when evaluations of the objective function are expensive and/or noisy.

\sphinxAtStartPar
That is, Py\sphinxhyphen{}BOBYQA solves
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  &\quad  f(x)\\
\text{s.t.} &\quad  a \leq x \leq b \\
&\quad x \in C := C_1 \cap \cdots \cap C_n, \quad \text{all $C_i$ convex}\end{split}
\end{equation*}
\sphinxAtStartPar
If provided, the constraints the variables are non\sphinxhyphen{}relaxable (i.e. Py\sphinxhyphen{}BOBYQA will never ask to evaluate a point outside the bounds),
although the general \(x \in C\) constraint may be slightly violated from rounding errors.

\sphinxAtStartPar
Full details of the Py\sphinxhyphen{}BOBYQA algorithm are given in our papers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Coralia Cartis, Jan Fiala, Benjamin Marteau and Lindon Roberts, \sphinxhref{https://doi.org/10.1145/3338517}{Improving the Flexibility and Robustness of Model\sphinxhyphen{}Based Derivative\sphinxhyphen{}Free Optimization Solvers}, \sphinxstyleemphasis{ACM Transactions on Mathematical Software}, 45:3 (2019), pp. 32:1\sphinxhyphen{}32:41 {[}\sphinxhref{https://arxiv.org/abs/1804.00154}{preprint}{]}

\item {} 
\sphinxAtStartPar
Coralia Cartis, Lindon Roberts and Oliver Sheridan\sphinxhyphen{}Methven, \sphinxhref{https://doi.org/10.1080/02331934.2021.1883015}{Escaping local minima with derivative\sphinxhyphen{}free methods: a numerical investigation}, \sphinxstyleemphasis{Optimization}, 71:8 (2022), pp. 2343\sphinxhyphen{}2373. {[}\sphinxhref{https://arxiv.org/abs/1812.11343}{arXiv preprint: 1812.11343}{]}

\item {} 
\sphinxAtStartPar
Lindon Roberts, \sphinxhref{https://arxiv.org/abs/2403.14960}{Model Construction for Convex\sphinxhyphen{}Constrained Derivative\sphinxhyphen{}Free Optimization}, \sphinxstyleemphasis{arXiv preprint arXiv:2403.14960} (2024).

\end{enumerate}

\sphinxAtStartPar
Please cite {[}1{]} when using Py\sphinxhyphen{}BOBYQA for local optimization, {[}1,2{]} when using Py\sphinxhyphen{}BOBYQAâ€™s global optimization heuristic functionality, and {[}1,3{]} if using the general convex constraints \(x \in C\) functionality.

\sphinxAtStartPar
If you are interested in solving least\sphinxhyphen{}squares minimization problems, you may wish to try \sphinxhref{https://github.com/numericalalgorithmsgroup/dfols}{DFO\sphinxhyphen{}LS}, which has the same features as Py\sphinxhyphen{}BOBYQA (plus some more), and exploits the least\sphinxhyphen{}squares problem structure, so performs better on such problems.

\sphinxAtStartPar
Since v1.1, Py\sphinxhyphen{}BOBYQA has a heuristic for global optimization (see {\hyperref[\detokenize{userguide::doc}]{\sphinxcrossref{\DUrole{doc}{Using Py\sphinxhyphen{}BOBYQA}}}} for details). As this is a heuristic, there are no guarantees it will find a global minimum, but it is more likely to escape local minima if there are better values nearby.

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is released under the GNU General Public License. Please \sphinxhref{http://www.nag.com/content/worldwide-contact-information}{contact NAG} for alternative licensing.

\sphinxstepscope


\chapter{Installing Py\sphinxhyphen{}BOBYQA}
\label{\detokenize{install:installing-py-bobyqa}}\label{\detokenize{install::doc}}

\section{Requirements}
\label{\detokenize{install:requirements}}
\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA requires the following software to be installed:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Python 3.8 or higher (\sphinxurl{http://www.python.org/})

\end{itemize}

\sphinxAtStartPar
Additionally, the following python packages should be installed (these will be installed automatically if using \sphinxhref{http://www.pip-installer.org/}{pip}, see {\hyperref[\detokenize{install:installation-using-pip}]{\sphinxcrossref{Installation using pip}}}):
\begin{itemize}
\item {} 
\sphinxAtStartPar
NumPy (\sphinxurl{http://www.numpy.org/})

\item {} 
\sphinxAtStartPar
SciPy (\sphinxurl{http://www.scipy.org/})

\item {} 
\sphinxAtStartPar
Pandas (\sphinxurl{http://pandas.pydata.org/})

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Optional package:} Py\sphinxhyphen{}BOBYQA versions 1.2 and higher also support the \sphinxhref{https://github.com/lindonroberts/trust-region}{trustregion} package for fast trust\sphinxhyphen{}region subproblem solutions. To install this, make sure you have a Fortran compiler (e.g. \sphinxhref{https://gcc.gnu.org/wiki/GFortran}{gfortran}) and NumPy installed, then run \sphinxcode{\sphinxupquote{pip install trustregion}}. You do not have to have trustregion installed for Py\sphinxhyphen{}BOBYQA to work, and it is not installed by default.


\section{Installation using pip}
\label{\detokenize{install:installation-using-pip}}
\sphinxAtStartPar
For easy installation, use \sphinxhref{http://www.pip-installer.org/}{pip}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }Py\PYGZhy{}BOBYQA
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Note that if an older install of Py\sphinxhyphen{}BOBYQA is present on your system you can use:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}upgrade\PYG{+w}{ }Py\PYGZhy{}BOBYQA
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
to upgrade Py\sphinxhyphen{}BOBYQA to the latest version.


\section{Manual installation}
\label{\detokenize{install:manual-installation}}
\sphinxAtStartPar
The source code for Py\sphinxhyphen{}BOBYQA is \sphinxhref{https://github.com/numericalalgorithmsgroup/pybobyqa}{available on Github}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/numericalalgorithmsgroup/pybobyqa
\PYGZdl{}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }pybobyqa
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is written in pure Python and requires no compilation. It can be installed using:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }.
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
To upgrade Py\sphinxhyphen{}BOBYQA to the latest version, navigate to the top\sphinxhyphen{}level directory (i.e. the one containing \sphinxcode{\sphinxupquote{setup.py}}) and rerun the installation using \sphinxcode{\sphinxupquote{pip}}, as above:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }pull
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }.
\end{sphinxVerbatim}
\end{quote}


\section{Testing}
\label{\detokenize{install:testing}}
\sphinxAtStartPar
If you installed Py\sphinxhyphen{}BOBYQA manually, you can test your installation using the pytest package:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }pytest
\PYGZdl{}\PYG{+w}{ }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pytest\PYG{+w}{ }\PYGZhy{}\PYGZhy{}pyargs\PYG{+w}{ }pybobyqa
\end{sphinxVerbatim}
\end{quote}


\section{Uninstallation}
\label{\detokenize{install:uninstallation}}
\sphinxAtStartPar
If Py\sphinxhyphen{}BOBYQA was installed using \sphinxhref{http://www.pip-installer.org/}{pip} you can uninstall as follows:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }uninstall\PYG{+w}{ }Py\PYGZhy{}BOBYQA
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
If Py\sphinxhyphen{}BOBYQA was installed manually you have to remove the installed files by hand (located in your python site\sphinxhyphen{}packages directory).

\sphinxstepscope


\chapter{Overview}
\label{\detokenize{info:overview}}\label{\detokenize{info::doc}}

\section{When to use Py\sphinxhyphen{}BOBYQA}
\label{\detokenize{info:when-to-use-py-bobyqa}}
\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is designed to solve the nonlinear least\sphinxhyphen{}squares minimization problem (with optional bound and general convex constraints)
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  &\quad  f(x)\\
\text{s.t.} &\quad  a \leq x \leq b\\
&\quad x \in C := C_1 \cap \cdots \cap C_n, \quad \text{all $C_i$ convex}\end{split}
\end{equation*}
\sphinxAtStartPar
We call \(f(x)\) the objective function.

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is a \sphinxstyleemphasis{derivative\sphinxhyphen{}free} optimization algorithm, which means it does not require the user to provide the derivatives of \(f(x)\), nor does it attempt to estimate them internally (by using finite differencing, for instance).

\sphinxAtStartPar
There are two main situations when using a derivative\sphinxhyphen{}free algorithm (such as Py\sphinxhyphen{}BOBYQA) is preferable to a derivative\sphinxhyphen{}based algorithm (which is the vast majority of least\sphinxhyphen{}squares solvers).

\sphinxAtStartPar
If \sphinxstylestrong{the residuals are noisy}, then calculating or even estimating their derivatives may be impossible (or at least very inaccurate). By noisy, we mean that if we evaluate \(f(x)\) multiple times at the same value of \(x\), we get different results. This may happen when a Monte Carlo simulation is used, for instance, or \(f(x)\) involves performing a physical experiment.

\sphinxAtStartPar
If \sphinxstylestrong{the residuals are expensive to evaluate}, then estimating derivatives (which requires \(n\) evaluations of \(f(x)\) for every point of interest \(x\)) may be prohibitively expensive. Derivative\sphinxhyphen{}free methods are designed to solve the problem with the fewest number of evaluations of the objective as possible.

\sphinxAtStartPar
\sphinxstylestrong{However, if you have provide (or a solver can estimate) derivatives} of \(f(x)\), then it is probably a good idea to use one of the many derivative\sphinxhyphen{}based solvers (such as \sphinxhref{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\#scipy.optimize.minimize}{one from the SciPy library}).


\section{Details of the Py\sphinxhyphen{}BOBYQA Algorithm}
\label{\detokenize{info:details-of-the-py-bobyqa-algorithm}}
\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is a type of \sphinxstyleemphasis{trust\sphinxhyphen{}region} method, a common category of optimization algorithms for nonconvex problems. Given a current estimate of the solution \(x_k\), we compute a model which approximates the objective \(m_k(s)\approx f(x_k+s)\) (for small steps \(s\)), and maintain a value \(\Delta_k>0\) (called the \sphinxstyleemphasis{trust region radius}) which measures the size of \(s\) for which the approximation is good.

\sphinxAtStartPar
At each step, we compute a trial step \(s_k\) designed to make our approximation \(m_k(s)\) small (this task is called the \sphinxstyleemphasis{trust region subproblem}). We evaluate the objective at this new point, and if this provided a good decrease in the objective, we take the step (\(x_{k+1}=x_k+s_k\)), otherwise we stay put (\(x_{k+1}=x_k\)). Based on this information, we choose a new value \(\Delta_{k+1}\), and repeat the process.

\sphinxAtStartPar
In Py\sphinxhyphen{}BOBYQA, we construct our approximation \(m_k(s)\) by interpolating a linear or quadratic approximation for \(f(x)\) at several points close to \(x_k\). To make sure our interpolated model is accurate, we need to regularly check that the points are well\sphinxhyphen{}spaced, and move them if they arenâ€™t (i.e. improve the geometry of our interpolation points).

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is a Python implementation of the BOBYQA solver by Powell \sphinxcite{info:powell2009}. More details about Py\sphinxhyphen{}BOBYQA algorithm are given in our paper \sphinxcite{userguide:cfmr2018}.


\section{References}
\label{\detokenize{info:references}}
\sphinxstepscope


\chapter{Using Py\sphinxhyphen{}BOBYQA}
\label{\detokenize{userguide:using-py-bobyqa}}\label{\detokenize{userguide::doc}}
\sphinxAtStartPar
This section describes the main interface to Py\sphinxhyphen{}BOBYQA and how to use it.


\section{Nonlinear Minimization}
\label{\detokenize{userguide:nonlinear-minimization}}
\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA is designed to solve the local optimization problem
\begin{equation*}
\begin{split}\min_{x\in\mathbb{R}^n}  &\quad  f(x) \\
\text{s.t.} &\quad  a \leq x \leq b\\
&\quad x \in C := C_1 \cap \cdots \cap C_n, \quad \text{all $C_i$ convex}\end{split}
\end{equation*}
\sphinxAtStartPar
where the bound constraints \(a \leq x \leq b\) and general convex constraints \(x \in C\) are optional.
The upper and lower bounds on the variables are non\sphinxhyphen{}relaxable (i.e. Py\sphinxhyphen{}BOBYQA will never ask to evaluate a point outside the bounds).
The general convex constraints are also non\sphinxhyphen{}relaxable, but they may be slightly violated at some points from rounding errors.
The objective function \(f(x)\) is usually nonlinear and nonquadratic.
If you know your objective is linear or quadratic, you should consider a solver designed for such functions (see \sphinxhref{https://neos-guide.org/Optimization-Guide}{here} for details).

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA iteratively constructs an interpolation\sphinxhyphen{}based model for the objective, and determines a step using a trust\sphinxhyphen{}region framework.
For an in\sphinxhyphen{}depth technical description of the algorithm see the paper \sphinxcite{userguide:cfmr2018}, and for the global optimization heuristic, see \sphinxcite{userguide:cro2022}.
For details about how Py\sphinxhyphen{}BOBYQA handles general convex constraints, see \sphinxcite{userguide:r2024}.


\section{How to use Py\sphinxhyphen{}BOBYQA}
\label{\detokenize{userguide:how-to-use-py-bobyqa}}
\sphinxAtStartPar
The main interface to Py\sphinxhyphen{}BOBYQA is via the function \sphinxcode{\sphinxupquote{solve}}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{objfun}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
The input \sphinxcode{\sphinxupquote{objfun}} is a Python function which takes an input \(x\in\mathbb{R}^n\) and returns the objective value \(f(x)\in\mathbb{R}\). The input of \sphinxcode{\sphinxupquote{objfun}} must be one\sphinxhyphen{}dimensional NumPy arrays (i.e. with \sphinxcode{\sphinxupquote{x.shape == (n,)}}) and the output must be a single Float.

\sphinxAtStartPar
The input \sphinxcode{\sphinxupquote{x0}} is the starting point for the solver, and (where possible) should be set to be the best available estimate of the true solution \(x_{min}\in\mathbb{R}^n\). It should be specified as a one\sphinxhyphen{}dimensional NumPy array (i.e. with \sphinxcode{\sphinxupquote{x0.shape == (n,)}}).
As Py\sphinxhyphen{}BOBYQA is a local solver, providing different values for \sphinxcode{\sphinxupquote{x0}} may cause it to return different solutions, with possibly different objective values.

\sphinxAtStartPar
The output of \sphinxcode{\sphinxupquote{pybobyqa.solve}} is an object containing:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.x}} \sphinxhyphen{} an estimate of the solution, \(x_{min}\in\mathbb{R}^n\), a one\sphinxhyphen{}dimensional NumPy array.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.f}} \sphinxhyphen{} the objective value at the calculated solution, \(f(x_{min})\), a Float.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.gradient}} \sphinxhyphen{} an estimate of the gradient vector of first derivatives of the objective, \(g_i \approx \partial f(x_{min})/\partial x_i\), a NumPy array of length \(n\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.hessian}} \sphinxhyphen{} an estimate of the Hessian matrix of second derivatives of the objective, \(H_{i,j} \approx \partial^2 f(x_{min})/\partial x_i \partial x_j\), a NumPy array of size \(n\times n\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.nf}} \sphinxhyphen{} the number of evaluations of \sphinxcode{\sphinxupquote{objfun}} that the algorithm needed, an Integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.nx}} \sphinxhyphen{} the number of points \(x\) at which \sphinxcode{\sphinxupquote{objfun}} was evaluated, an Integer. This may be different to \sphinxcode{\sphinxupquote{soln.nf}} if sample averaging is used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.nruns}} \sphinxhyphen{} the number of runs performed by Py\sphinxhyphen{}BOBYQA (more than 1 if using multiple restarts), an Integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.flag}} \sphinxhyphen{} an exit flag, which can take one of several values (listed below), an Integer.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.msg}} \sphinxhyphen{} a description of why the algorithm finished, a String.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.diagnostic\_info}} \sphinxhyphen{} a table of diagnostic information showing the progress of the solver, a Pandas DataFrame.

\end{itemize}

\sphinxAtStartPar
The possible values of \sphinxcode{\sphinxupquote{soln.flag}} are defined by the following variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_SUCCESS}} \sphinxhyphen{} Py\sphinxhyphen{}BOBYQA terminated successfully (the objective value or trust region radius are sufficiently small).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_MAXFUN\_WARNING}} \sphinxhyphen{} maximum allowed objective evaluations reached. This is the most likely return value when using multiple restarts.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_SLOW\_WARNING}} \sphinxhyphen{} maximum number of slow iterations reached.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_FALSE\_SUCCESS\_WARNING}} \sphinxhyphen{} Py\sphinxhyphen{}BOBYQA reached the maximum number of restarts which decreased the objective, but to a worse value than was found in a previous run.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_INPUT\_ERROR}} \sphinxhyphen{} error in the inputs.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_TR\_INCREASE\_ERROR}} \sphinxhyphen{} error occurred when solving the trust region subproblem.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{soln.EXIT\_LINALG\_ERROR}} \sphinxhyphen{} linear algebra error, e.g. the interpolation points produced a singular linear system.

\end{itemize}

\sphinxAtStartPar
These variables are defined in the \sphinxcode{\sphinxupquote{soln}} object, so can be accessed with, for example
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{flag} \PYG{o}{==} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{EXIT\PYGZus{}SUCCESS}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Success!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\section{Optional Arguments}
\label{\detokenize{userguide:optional-arguments}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{solve}} function has several optional arguments which the user may provide:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{objfun}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bounds}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{projections}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
               \PYG{n}{npt}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{rhobeg}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{rhoend}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{,} \PYG{n}{maxfun}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}
               \PYG{n}{nsamples}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{user\PYGZus{}params}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{objfun\PYGZus{}has\PYGZus{}noise}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
               \PYG{n}{seek\PYGZus{}global\PYGZus{}minimum}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
               \PYG{n}{scaling\PYGZus{}within\PYGZus{}bounds}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
               \PYG{n}{do\PYGZus{}logging}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{print\PYGZus{}progress}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
These arguments are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{args}} \sphinxhyphen{} a tuple of extra arguments passed to the objective function.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bounds}} \sphinxhyphen{} a tuple \sphinxcode{\sphinxupquote{(lower, upper)}} with the vectors \(a\) and \(b\) of lower and upper bounds on \(x\) (default is \(a_i=-10^{20}\) and \(b_i=10^{20}\)). To set bounds for either \sphinxcode{\sphinxupquote{lower}} or \sphinxcode{\sphinxupquote{upper}}, but not both, pass a tuple \sphinxcode{\sphinxupquote{(lower, None)}} or \sphinxcode{\sphinxupquote{(None, upper)}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{projections}} \sphinxhyphen{} a list of functions defining the Euclidean projections for each general convex constraint \(C_i\). Each element of the list \sphinxcode{\sphinxupquote{projections}} is a function that takes an input vector \(x\) and returns the closest point to \(x\) that is in \(C_i\). An example of using this is given below.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npt}} \sphinxhyphen{} the number of interpolation points to use (default is \(2n+1\) for a problem with \sphinxcode{\sphinxupquote{len(x0)=n}} if \sphinxcode{\sphinxupquote{objfun\_has\_noise=False}}, otherwise it is set to \((n+1)(n+2)/2\)). Py\sphinxhyphen{}BOBYQA requires \(n+1 \leq npt \leq (n+1)(n+2)/2\). Larger values are particularly useful for noisy problems.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rhobeg}} \sphinxhyphen{} the initial value of the trust region radius (default is 0.1 if \sphinxcode{\sphinxupquote{scaling\_within\_bounds=True}}, otherwise \(0.1\max(\|x_0\|_{\infty}, 1)\)).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rhoend}} \sphinxhyphen{} minimum allowed value of trust region radius, which determines when a successful termination occurs (default is \(10^{-8}\)).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxfun}} \sphinxhyphen{} the maximum number of objective evaluations the algorithm may request (default is \(\min(100(n+1),1000)\)).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsamples}} \sphinxhyphen{} a Python function \sphinxcode{\sphinxupquote{nsamples(delta, rho, iter, nrestarts)}} which returns the number of times to evaluate \sphinxcode{\sphinxupquote{objfun}} at a given point. This is only applicable for objectives with stochastic noise, when averaging multiple evaluations at the same point produces a more accurate value. The input parameters are the trust region radius (\sphinxcode{\sphinxupquote{delta}}), the lower bound on the trust region radius (\sphinxcode{\sphinxupquote{rho}}), how many iterations the algorithm has been running for (\sphinxcode{\sphinxupquote{iter}}), and how many restarts have been performed (\sphinxcode{\sphinxupquote{nrestarts}}). Default is no averaging (i.e. \sphinxcode{\sphinxupquote{nsamples(delta, rho, iter, nrestarts)=1}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{user\_params}} \sphinxhyphen{} a Python dictionary \sphinxcode{\sphinxupquote{\{\textquotesingle{}param1\textquotesingle{}: val1, \textquotesingle{}param2\textquotesingle{}:val2, ...\}}} of optional parameters. A full list of available options is given in the next section {\hyperref[\detokenize{advanced::doc}]{\sphinxcrossref{\DUrole{doc}{Advanced Usage}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{objfun\_has\_noise}} \sphinxhyphen{} a flag to indicate whether or not \sphinxcode{\sphinxupquote{objfun}} has stochastic noise; i.e. will calling \sphinxcode{\sphinxupquote{objfun(x)}} multiple times at the same value of \sphinxcode{\sphinxupquote{x}} give different results? This is used to set some sensible default parameters (including using multiple restarts), all of which can be overridden by the values provided in \sphinxcode{\sphinxupquote{user\_params}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seek\_global\_minimum}} \sphinxhyphen{} a flag to indicate whether to search for a global minimum, rather than a local minimum. This is used to set some sensible default parameters, all of which can be overridden by the values provided in \sphinxcode{\sphinxupquote{user\_params}}. If \sphinxcode{\sphinxupquote{True}}, both upper and lower bounds must be set. Note that Py\sphinxhyphen{}BOBYQA only implements a heuristic method, so there are no guarantees it will find a global minimum. However, by using this flag, it is more likely to escape local minima if there are better values nearby. The method used is a multiple restart mechanism, where we repeatedly re\sphinxhyphen{}initialize Py\sphinxhyphen{}BOBYQA from the best point found so far, but where we use a larger trust reigon radius each time (note: this is different to more common multi\sphinxhyphen{}start approach to global optimization).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scaling\_within\_bounds}} \sphinxhyphen{} a flag to indicate whether the algorithm should internally shift and scale the entries of \sphinxcode{\sphinxupquote{x}} so that the bounds become \(0 \leq x \leq 1\). This is useful is you are setting \sphinxcode{\sphinxupquote{bounds}} and the bounds have different orders of magnitude. If \sphinxcode{\sphinxupquote{scaling\_within\_bounds=True}}, the values of \sphinxcode{\sphinxupquote{rhobeg}} and \sphinxcode{\sphinxupquote{rhoend}} apply to the \sphinxstyleemphasis{shifted} variables.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{do\_logging}} \sphinxhyphen{} a flag to indicate whether logging output should be produced. This is not automatically visible unless you use the Python \sphinxhref{https://docs.python.org/3/library/logging.html}{logging} module (see below for simple usage).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{print\_progress}} \sphinxhyphen{} a flag to indicate whether to print a per\sphinxhyphen{}iteration progress log to terminal.

\end{itemize}

\sphinxAtStartPar
In general when using optimization software, it is good practice to scale your variables so that moving each by a given amount has approximately the same impact on the objective function.
The \sphinxcode{\sphinxupquote{scaling\_within\_bounds}} flag is designed to provide an easy way to achieve this, if you have set the bounds \sphinxcode{\sphinxupquote{lower}} and \sphinxcode{\sphinxupquote{upper}}.


\section{A Simple Example}
\label{\detokenize{userguide:a-simple-example}}
\sphinxAtStartPar
Suppose we wish to minimize the \sphinxhref{https://en.wikipedia.org/wiki/Rosenbrock\_function}{Rosenbrock test function}:
\begin{equation*}
\begin{split}\min_{(x_1,x_2)\in\mathbb{R}^2}  &\quad  100(x_2-x_1^2)^2 + (1-x_1)^2 \\\end{split}
\end{equation*}
\sphinxAtStartPar
This function has exactly one local minimum \(f(x_{min})=0\) at \(x_{min}=(1,1)\). A commonly\sphinxhyphen{}used starting point for testing purposes is \(x_0=(-1.2,1)\). The following script shows how to solve this problem using Py\sphinxhyphen{}BOBYQA:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Py\PYGZhy{}BOBYQA example: minimize the Rosenbrock function}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pybobyqa}

\PYG{c+c1}{\PYGZsh{} Define the objective function}
\PYG{k}{def} \PYG{n+nf}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mf}{100.0} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call Py\PYGZhy{}BOBYQA}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display output}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Note that Py\sphinxhyphen{}BOBYQA is a randomized algorithm: in its first phase, it builds an internal approximation to the objective function by sampling it along random directions. In the code above, we set NumPyâ€™s random seed for reproducibility over multiple runs, but this is not required. The output of this script, showing that Py\sphinxhyphen{}BOBYQA finds the correct solution, is
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [1. 1.]
Objective value f(xmin) = 1.013856052e\PYGZhy{}20
Needed 151 objective evaluations (at 151 points)
Approximate gradient = [ 2.35772499e\PYGZhy{}08 \PYGZhy{}1.07598803e\PYGZhy{}08]
Approximate Hessian = [[ 802.00799968 \PYGZhy{}400.04089119]
 [\PYGZhy{}400.04089119  199.99228723]]
Exit flag = 0
Success: rho has reached rhoend
******************************
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
This and all following problems can be found in the \sphinxhref{https://github.com/numericalalgorithmsgroup/pybobyqa/tree/master/examples}{examples} directory on the Py\sphinxhyphen{}BOBYQA Github page.


\section{Adding Bounds and More Output}
\label{\detokenize{userguide:adding-bounds-and-more-output}}
\sphinxAtStartPar
We can extend the above script to add constraints. To do this, we can add the lines
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define bound constraints (lower \PYGZlt{}= x \PYGZlt{}= upper)}
\PYG{n}{lower} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{10.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{upper} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{0.85}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call Py\PYGZhy{}BOBYQA (with bounds)}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{n}{lower}\PYG{p}{,}\PYG{n}{upper}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA correctly finds the solution to the constrained problem:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [0.9  0.81]
Objective value f(xmin) = 0.01
Needed 146 objective evaluations (at 146 points)
Approximate gradient = [\PYGZhy{}2.00000006e\PYGZhy{}01 \PYGZhy{}4.74578563e\PYGZhy{}09]
Approximate Hessian = [[ 649.66398033 \PYGZhy{}361.03094781]
 [\PYGZhy{}361.03094781  199.94223213]]
Exit flag = 0
Success: rho has reached rhoend
******************************
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
However, we also get a warning that our starting point was outside of the bounds:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
RuntimeWarning: x0 above upper bound, adjusting
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA automatically fixes this, and moves \(x_0\) to a point within the bounds, in this case \(x_0=(-1.2,0.85)\).

\sphinxAtStartPar
We can also get Py\sphinxhyphen{}BOBYQA to print out more detailed information about its progress using the \sphinxhref{https://docs.python.org/3/library/logging.html}{logging} module. To do this, we need to add the following lines:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{basicConfig}\PYG{p}{(}\PYG{n}{level}\PYG{o}{=}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} ... (call pybobyqa.solve)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
And we can now see each evaluation of \sphinxcode{\sphinxupquote{objfun}}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Function eval 1 at point 1 has f = 39.65 at x = [\PYGZhy{}1.2   0.85]
Initialising (coordinate directions)
Function eval 2 at point 2 has f = 14.337296 at x = [\PYGZhy{}1.08  0.85]
Function eval 3 at point 3 has f = 55.25 at x = [\PYGZhy{}1.2   0.73]
...
Function eval 145 at point 145 has f = 0.0100000013172792 at x = [0.89999999 0.80999999]
Function eval 146 at point 146 has f = 0.00999999999999993 at x = [0.9  0.81]
Did a total of 1 run(s)
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
If we wanted to save this output to a file, we could replace the above call to \sphinxcode{\sphinxupquote{logging.basicConfig()}} with
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{basicConfig}\PYG{p}{(}\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myfile.log}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{level}\PYG{o}{=}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{INFO}\PYG{p}{,}
                    \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{filemode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
If you have logging for some parts of your code and you want to deactivate all Py\sphinxhyphen{}BOBYQA logging, you can use the optional argument \sphinxcode{\sphinxupquote{do\_logging=False}} in \sphinxcode{\sphinxupquote{pybobyqa.solve()}}.

\sphinxAtStartPar
An alternative option available is to get Py\sphinxhyphen{}BOBYQA to print to terminal progress information every iteration, by setting the optional argument \sphinxcode{\sphinxupquote{print\_progress=True}} in \sphinxcode{\sphinxupquote{pybobyqa.solve()}}. If we do this for the above example, we get
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 Run  Iter     Obj       Grad     Delta      rho     Evals
  1     1    1.43e+01  1.74e+02  1.20e\PYGZhy{}01  1.20e\PYGZhy{}01    5
  1     2    5.57e+00  1.20e+02  3.66e\PYGZhy{}01  1.20e\PYGZhy{}01    6
  1     3    5.57e+00  1.20e+02  6.00e\PYGZhy{}02  1.20e\PYGZhy{}02    6
...
  1    132   1.00e\PYGZhy{}02  2.00e\PYGZhy{}01  1.50e\PYGZhy{}08  1.00e\PYGZhy{}08   144
  1    133   1.00e\PYGZhy{}02  2.00e\PYGZhy{}01  1.50e\PYGZhy{}08  1.00e\PYGZhy{}08   145
\end{sphinxVerbatim}
\end{quote}


\section{Adding General Convex Constraints}
\label{\detokenize{userguide:adding-general-convex-constraints}}
\sphinxAtStartPar
We can also add more general convex constraints \(x \in C := C_1 \cap \cdots \cap C_n\) to our problem, where
each \(C_i\) is a convex set. To do this, we need to know the Euclidean projection operator for each \(C_i\):
\begin{equation*}
\begin{split}\operatorname{proj}_{C_i}(x) := \operatorname{argmin}_{y\in C_i} \|y-x\|_2^2.\end{split}
\end{equation*}
\sphinxAtStartPar
i.e. given a point \(x\), return the closest point to \(x\) in the set \(C_i\).
There are many examples of simple convex sets \(C_i\) for which this function has a known, simple form, such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Bound constraints (but since Py\sphinxhyphen{}BOBYQA supports this directly, it is better to give these explicitly via the \sphinxcode{\sphinxupquote{bounds}} input, as above)

\item {} 
\sphinxAtStartPar
Euclidean ball constraints: \(\|x-c\|_2 \leq r\)

\item {} 
\sphinxAtStartPar
Unit simplex: \(x_i \geq 0\) and \(\sum_{i=1}^{n} x_i \leq 1\)

\item {} 
\sphinxAtStartPar
Linear inequalities: \(a^T x \geq b\)

\end{itemize}

\sphinxAtStartPar
In Py\sphinxhyphen{}BOBYQA, set the input \sphinxcode{\sphinxupquote{projections}} to be a list of projection functions, one per \(C_i\).
Internally, Py\sphinxhyphen{}BOBYQA computes the projection onto the intersection of these sets and the bound constraints
using \sphinxhref{https://en.wikipedia.org/wiki/Dykstra\%27s\_projection\_algorithm}{Dykstraâ€™s projection algorithm}.

\sphinxAtStartPar
For the explicit expressions for the above projections, and more examples, see for example \sphinxhref{https://proximity-operator.net/indicatorfunctions.html}{this online database}
or Section 6.4.6 of the textbook \sphinxcite{userguide:b2017}.

\sphinxAtStartPar
As an example, letâ€™s minimize the above Rosenbrock function with different bounds, and with a Euclidean
ball constraint, namely \((x_1-0.5)^2 + (x_2-1)^2 \leq 0.25^2\).

\sphinxAtStartPar
To do this, we can run
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pybobyqa}

\PYG{c+c1}{\PYGZsh{} Define the objective function}
\PYG{k}{def} \PYG{n+nf}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mf}{100.0} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define bound constraints (lower \PYGZlt{}= x \PYGZlt{}= upper)}
\PYG{n}{lower} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{upper} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the ball constraint ||x\PYGZhy{}center|| \PYGZlt{}= radius, and its projection operator}
\PYG{n}{center} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{ball\PYGZus{}proj} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{center} \PYG{o}{+} \PYG{p}{(}\PYG{n}{radius}\PYG{o}{/}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{center}\PYG{p}{)}\PYG{p}{,} \PYG{n}{radius}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{center}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call Py\PYGZhy{}BOBYQA (with bounds and projection operator)}
\PYG{c+c1}{\PYGZsh{} Note: it is better to provide bounds explicitly, instead of using the corresponding}
\PYG{c+c1}{\PYGZsh{}       projection function}
\PYG{c+c1}{\PYGZsh{} Note: input \PYGZsq{}projections\PYGZsq{} must be a list of projection functions}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{n}{lower}\PYG{p}{,}\PYG{n}{upper}\PYG{p}{)}\PYG{p}{,} \PYG{n}{projections}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ball\PYGZus{}proj}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Py\sphinxhyphen{}BOBYQA correctly finds the solution to the constrained problem:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [0.70424386 0.85583188]
Objective value f(xmin) = 13.03829114
Needed 25 objective evaluations (at 25 points)
Approximate gradient = [\PYGZhy{}101.9667031    71.97449424]
Approximate Hessian = [[ 253.11858775 \PYGZhy{}279.39193327]
 [\PYGZhy{}279.39193327  201.49725358]]
Exit flag = 0
Success: rho has reached rhoend
******************************
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Just like for bound constraints, Py\sphinxhyphen{}BOBYQA will automatically ensure the starting point is feasible with respect to all constraints (bounds and general convex constraints).


\section{Example: Noisy Objective Evaluation}
\label{\detokenize{userguide:example-noisy-objective-evaluation}}
\sphinxAtStartPar
As described in {\hyperref[\detokenize{info::doc}]{\sphinxcrossref{\DUrole{doc}{Overview}}}}, derivative\sphinxhyphen{}free algorithms such as Py\sphinxhyphen{}BOBYQA are particularly useful when \sphinxcode{\sphinxupquote{objfun}} has noise. Letâ€™s modify the previous example to include random noise in our objective evaluation, and compare it to a derivative\sphinxhyphen{}based solver:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Py\PYGZhy{}BOBYQA example: minimize the noisy Rosenbrock function}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pybobyqa}

\PYG{c+c1}{\PYGZsh{} Define the objective function}
\PYG{k}{def} \PYG{n+nf}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mf}{100.0} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Modified objective function: add 1\PYGZpc{} Gaussian noise}
\PYG{k}{def} \PYG{n+nf}{rosenbrock\PYGZus{}noisy}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{rosenbrock}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.2}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set random seed (for reproducibility)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Demonstrate noise in function evaluation:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{objfun(x0) = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{(}\PYG{n}{x0}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Call Py\PYGZhy{}BOBYQA}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display output}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compare with a derivative\PYGZhy{}based solver}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k}{as} \PYG{n+nn}{opt}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{(}\PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{** SciPy results **}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Solution xmin = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Objective value f(xmin) = }\PYG{l+s+si}{\PYGZpc{}.10g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{fun}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Needed }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{ objective evaluations}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{nfev}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exit flag = }\PYG{l+s+si}{\PYGZpc{}g}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{soln}\PYG{o}{.}\PYG{n}{status}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{o}{.}\PYG{n}{message}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
The output of this is:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Demonstrate noise in function evaluation:
objfun(x0) = 24.6269
objfun(x0) = 24.2968
objfun(x0) = 24.4369
objfun(x0) = 24.7423
objfun(x0) = 24.6519

****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [\PYGZhy{}1.04327395  1.09935385]
Objective value f(xmin) = 4.080030471
Needed 42 objective evaluations (at 42 points)
Approximate gradient = [\PYGZhy{}3786376.5065785   5876675.51763198]
Approximate Hessian = [[ 1.32881117e+14 \PYGZhy{}2.68241358e+14]
 [\PYGZhy{}2.68241358e+14  6.09785319e+14]]
Exit flag = 0
Success: rho has reached rhoend
******************************


** SciPy results **
Solution xmin = [\PYGZhy{}1.20013817  0.99992915]
Objective value f(xmin) = 23.86371763
Needed 80 objective evaluations
Exit flag = 2
Desired error not necessarily achieved due to precision loss.
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Although Py\sphinxhyphen{}BOBYQA does not find the true solution (and it cannot produce a good estimate of the objective gradient and Hessian), it still gives a reasonable decrease in the objective. However SciPyâ€™s derivative\sphinxhyphen{}based solver, which has no trouble solving the noise\sphinxhyphen{}free problem, is unable to make any progress.

\sphinxAtStartPar
As noted above, Py\sphinxhyphen{}BOBYQA has an input parameter \sphinxcode{\sphinxupquote{objfun\_has\_noise}} to indicate if \sphinxcode{\sphinxupquote{objfun}} has noise in it, which it does in this case. Therefore we can call Py\sphinxhyphen{}BOBYQA with
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{rosenbrock\PYGZus{}noisy}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{objfun\PYGZus{}has\PYGZus{}noise}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
This time, we find the true solution, and better estimates of the gradient and Hessian:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [1. 1.]
Objective value f(xmin) = 1.237351799e\PYGZhy{}19
Needed 300 objective evaluations (at 300 points)
Did a total of 5 runs
Approximate gradient = [\PYGZhy{}2.17072738e\PYGZhy{}07  9.62304351e\PYGZhy{}08]
Approximate Hessian = [[ 809.56521044 \PYGZhy{}400.33737779]
 [\PYGZhy{}400.33737779  198.36487985]]
Exit flag = 1
Warning (max evals): Objective has been called MAXFUN times
******************************
\end{sphinxVerbatim}
\end{quote}


\section{Example: Global Optimization}
\label{\detokenize{userguide:example-global-optimization}}
\sphinxAtStartPar
The following example shows how to use the global optimization features of Py\sphinxhyphen{}BOBYQA. Here, we try to minimize the Freudenstein and Roth function (problem 2 in J.J. MorÃ©, B.S. Garbow, B.S. and K.E. Hillstrom, Testing Unconstrained Optimization Software, \sphinxstyleemphasis{ACM Trans. Math. Software} 7:1 (1981), 17\sphinxhyphen{}41). This function has two local minima, one of which is global.

\sphinxAtStartPar
Note that Py\sphinxhyphen{}BOBYQA only implements a heuristic method, so there are no guarantees it will find a global minimum. However, by using the \sphinxcode{\sphinxupquote{seek\_global\_minimum}} flag, it is more likely to escape local minima if there are better values nearby.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Py\PYGZhy{}BOBYQA example: globally minimize the Freudenstein and Roth function}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pybobyqa}

\PYG{c+c1}{\PYGZsh{} Define the objective function}
\PYG{c+c1}{\PYGZsh{} This function has a local minimum f = 48.98}
\PYG{c+c1}{\PYGZsh{} at x = np.array([11.41, \PYGZhy{}0.8968])}
\PYG{c+c1}{\PYGZsh{} and a global minimum f = 0 at x = np.array([5.0, 4.0])}
\PYG{k}{def} \PYG{n+nf}{freudenstein\PYGZus{}roth}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{13.0} \PYG{o}{+} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{5.0} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{2.0}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{r2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{29.0} \PYG{o}{+} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{14.0}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{r1} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{r2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Define the starting point}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define bounds (required for global optimization)}
\PYG{n}{lower} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{30.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{30.0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{upper} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{30.0}\PYG{p}{,} \PYG{l+m+mf}{30.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set random seed (for reproducibility)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{First run \PYGZhy{} search for local minimum only}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{freudenstein\PYGZus{}roth}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{maxfun}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{,}
                      \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{n}{lower}\PYG{p}{,} \PYG{n}{upper}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Second run \PYGZhy{} search for global minimum}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{freudenstein\PYGZus{}roth}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{maxfun}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{,}
                      \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{n}{lower}\PYG{p}{,} \PYG{n}{upper}\PYG{p}{)}\PYG{p}{,}
                      \PYG{n}{seek\PYGZus{}global\PYGZus{}minimum}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{soln}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
The output of this is:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
First run \PYGZhy{} search for local minimum only

****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [11.41277902 \PYGZhy{}0.89680525]
Objective value f(xmin) = 48.98425368
Needed 143 objective evaluations (at 143 points)
Approximate gradient = [\PYGZhy{}1.64941396e\PYGZhy{}07  9.69795781e\PYGZhy{}07]
Approximate Hessian = [[   7.74717421 \PYGZhy{}104.51102613]
 [\PYGZhy{}104.51102613 1135.76500421]]
Exit flag = 0
Success: rho has reached rhoend
******************************



Second run \PYGZhy{} search for global minimum

****** Py\PYGZhy{}BOBYQA Results ******
Solution xmin = [5. 4.]
Objective value f(xmin) = 3.659891409e\PYGZhy{}17
Needed 500 objective evaluations (at 500 points)
Did a total of 5 runs
Approximate gradient = [ 8.70038835e\PYGZhy{}10 \PYGZhy{}4.64918043e\PYGZhy{}07]
Approximate Hessian = [[   4.28883646   64.16836253]
 [  64.16836253 3722.93109385]]
Exit flag = 1
Warning (max evals): Objective has been called MAXFUN times
******************************
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
As we can see, the \sphinxcode{\sphinxupquote{seek\_global\_minimum}} flag helped Py\sphinxhyphen{}BOBYQA escape the local minimum from the first run, and find the global minimum. More details are given in \sphinxcite{userguide:cro2022}.


\section{References}
\label{\detokenize{userguide:references}}
\sphinxstepscope


\chapter{Advanced Usage}
\label{\detokenize{advanced:advanced-usage}}\label{\detokenize{advanced::doc}}
\sphinxAtStartPar
This section describes different optional user parameters available in Py\sphinxhyphen{}BOBYQA.

\sphinxAtStartPar
In the last section ({\hyperref[\detokenize{userguide::doc}]{\sphinxcrossref{\DUrole{doc}{Using Py\sphinxhyphen{}BOBYQA}}}}), we introduced \sphinxcode{\sphinxupquote{pybobyqa.solve()}}, which has the optional input \sphinxcode{\sphinxupquote{user\_params}}. This is a Python dictionary of user parameters. We will now go through the settings which can be changed in this way. More details are available in the paper \sphinxcite{userguide:cfmr2018}.

\sphinxAtStartPar
The default values, used if no override is given, in some cases vary depending on whether \sphinxcode{\sphinxupquote{objfun}} has stochastic noise; that is, whether evaluating \sphinxcode{\sphinxupquote{objfun(x)}} several times at the same \sphinxcode{\sphinxupquote{x}} gives the same result or not. Whether or not this is the case is determined by the \sphinxcode{\sphinxupquote{objfun\_has\_noise}} input to \sphinxcode{\sphinxupquote{pybobyqa.solve()}} (and not by inspecting \sphinxcode{\sphinxupquote{objfun}}, for instance). Similarly, the default values depend on the input flag \sphinxcode{\sphinxupquote{seek\_global\_minimum}}, i.e. if a global minimum is desired.


\section{General Algorithm Parameters}
\label{\detokenize{advanced:general-algorithm-parameters}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{general.rounding\_error\_constant}} \sphinxhyphen{} Internally, all interpolation points are stored with respect to a base point \(x_b\); that is, we store \(\{y_t-x_b\}\), which reduces the risk of roundoff errors. We shift \(x_b\) to \(x_k\) when \(\|s_k\| \leq \text{const}\|x_k-x_b\|\), where â€˜constâ€™ is this parameter. Default is 0.1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{general.safety\_step\_thresh}} \sphinxhyphen{} Threshold for when to call the safety step, \(\|s_k\| \leq \gamma_S \rho_k\). Default is \(\gamma_S =0.5\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{general.check\_objfun\_for\_overflow}} \sphinxhyphen{} Whether to cap the value of \(r_i(x)\) when they are large enough that an OverflowError will be encountered when trying to evaluate \(f(x)\). Default is \sphinxcode{\sphinxupquote{True}}.

\end{itemize}


\section{Logging and Output}
\label{\detokenize{advanced:logging-and-output}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logging.n\_to\_print\_whole\_x\_vector}} \sphinxhyphen{} If printing all function evaluations to screen/log file, the maximum \sphinxcode{\sphinxupquote{len(x)}} for which the full vector \sphinxcode{\sphinxupquote{x}} should be printed also. Default is 6.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logging.save\_diagnostic\_info}} \sphinxhyphen{} Flag so save diagnostic information at each iteration. Default is \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logging.save\_poisedness}} \sphinxhyphen{} If saving diagnostic information, whether to include the \(\Lambda\)\sphinxhyphen{}poisedness of \(Y_k\) in the diagnostic information. This is the most computationally expensive piece of diagnostic information. Default is \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logging.save\_xk}} \sphinxhyphen{} If saving diagnostic information, whether to include the full vector \(x_k\). Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}


\section{Initialization of Points}
\label{\detokenize{advanced:initialization-of-points}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init.random\_initial\_directions}} \sphinxhyphen{} Build the initial interpolation set using random directions (as opposed to coordinate directions). Default is \sphinxcode{\sphinxupquote{True}}. Not used if general convex constraints provided.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init.random\_directions\_make\_orthogonal}} \sphinxhyphen{} If building initial interpolation set with random directions, whether or not these should be orthogonalized. Default is \sphinxcode{\sphinxupquote{True}}. Not used if general convex constraints provided.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{init.run\_in\_parallel}} \sphinxhyphen{} If using random directions, whether or not to ask for all \sphinxcode{\sphinxupquote{objfun}} to be evaluated at all points without any intermediate processing. Default is \sphinxcode{\sphinxupquote{False}}. Not used if general convex constraints provided.

\end{itemize}


\section{Trust Region Management}
\label{\detokenize{advanced:trust-region-management}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.eta1}} \sphinxhyphen{} Threshold for unsuccessful trust region iteration, \(\eta_1\). Default is 0.1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.eta2}} \sphinxhyphen{} Threshold for very successful trust region iteration, \(\eta_2\). Default is 0.7.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.gamma\_dec}} \sphinxhyphen{} Ratio to decrease \(\Delta_k\) in unsuccessful iteration, \(\gamma_{dec}\). Default is 0.5 for smooth problems or 0.98 for noisy problems (i.e. \sphinxcode{\sphinxupquote{objfun\_has\_noise = True}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.gamma\_inc}} \sphinxhyphen{} Ratio to increase \(\Delta_k\) in very successful iterations, \(\gamma_{inc}\). Default is 2.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.gamma\_inc\_overline}} \sphinxhyphen{} Ratio of \(\|s_k\|\) to increase \(\Delta_k\) by in very successful iterations, \(\overline{\gamma}_{inc}\). Default is 4.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.alpha1}} \sphinxhyphen{} Ratio to decrease \(\rho_k\) by when it is reduced, \(\alpha_1\). Default is 0.1 for smooth problems or 0.9 for noisy problems (i.e. \sphinxcode{\sphinxupquote{objfun\_has\_noise = True}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tr\_radius.alpha2}} \sphinxhyphen{} Ratio of \(\rho_k\) to decrease \(\Delta_k\) by when \(\rho_k\) is reduced, \(\alpha_2\). Default is 0.5 for smooth problems or 0.95 for noisy problems (i.e. \sphinxcode{\sphinxupquote{objfun\_has\_noise = True}}).

\end{itemize}


\section{Termination on Small Objective Value}
\label{\detokenize{advanced:termination-on-small-objective-value}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{model.abs\_tol}} \sphinxhyphen{} Tolerance on \(f(x_k)\); quit if \(f(x_k)\) is below this value. Default is \(-10^{20}\).

\end{itemize}


\section{Termination on Slow Progress}
\label{\detokenize{advanced:termination-on-slow-progress}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{slow.history\_for\_slow}} \sphinxhyphen{} History used to determine whether the current iteration is â€˜slowâ€™. Default is 5.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{slow.thresh\_for\_slow}} \sphinxhyphen{} Threshold for objective decrease used to determine whether the current iteration is â€˜slowâ€™. Default is \(10^{-8}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{slow.max\_slow\_iters}} \sphinxhyphen{} Number of consecutive slow successful iterations before termination (or restart). Default is \sphinxcode{\sphinxupquote{20*len(x0)}}.

\end{itemize}


\section{Stochastic Noise Information}
\label{\detokenize{advanced:stochastic-noise-information}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noise.quit\_on\_noise\_level}} \sphinxhyphen{} Flag to quit (or restart) if all \(f(y_t)\) are within noise level of \(f(x_k)\). Default is \sphinxcode{\sphinxupquote{False}} for smooth problems or \sphinxcode{\sphinxupquote{True}} for noisy problems.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noise.scale\_factor\_for\_quit}} \sphinxhyphen{} Factor of noise level to use in termination criterion. Default is 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noise.multiplicative\_noise\_level}} \sphinxhyphen{} Multiplicative noise level in \(f\). Can only specify one of multiplicative or additive noise levels. Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{noise.additive\_noise\_level}} \sphinxhyphen{} Additive noise level in \(f\). Can only specify one of multiplicative or additive noise levels. Default is \sphinxcode{\sphinxupquote{None}}.

\end{itemize}


\section{Interpolation Management}
\label{\detokenize{advanced:interpolation-management}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolation.precondition}} \sphinxhyphen{} whether or not to scale the interpolation linear system to improve conditioning. Default is \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolation.minimum\_change\_hessian}} \sphinxhyphen{} whether to solve the underdetermined quadratic interpolation problem by minimizing the Frobenius norm of the Hessian, or change in Hessian. Default is \sphinxcode{\sphinxupquote{True}}.

\end{itemize}


\section{Multiple Restarts}
\label{\detokenize{advanced:multiple-restarts}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.use\_restarts}} \sphinxhyphen{} Whether to do restarts when \(\rho_k\) reaches \(\rho_{end}\), or (optionally) when all points are within noise level of \(f(x_k)\). Default is \sphinxcode{\sphinxupquote{False}} for smooth problems or \sphinxcode{\sphinxupquote{True}} for noisy problems or when seeking a global minimum.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.max\_unsuccessful\_restarts}} \sphinxhyphen{} Maximum number of consecutive unsuccessful restarts allowed (i.e.\textasciitilde{}restarts which did not reduce the objective further). Default is 10.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.max\_unsuccessful\_restarts\_total}} \sphinxhyphen{} Maximum number of total unsuccessful restarts allowed. Default is 20 when seeking a global minimum, otherwise it is \sphinxcode{\sphinxupquote{maxfun}} (i.e.\textasciitilde{}not restricted).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.rhobeg\_scale\_after\_unsuccessful\_restart}} \sphinxhyphen{} Factor to increase \(\rho_{beg}\) by after unsuccessful restarts. Default is 1.1 when seeking a global minimum, otherwise it is 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.rhoend\_scale}} \sphinxhyphen{} Factor to reduce \(\rho_{end}\) by with each restart. Default is 1.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.use\_soft\_restarts}} \sphinxhyphen{} Whether to use soft or hard restarts. Default is \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.soft.num\_geom\_steps}} \sphinxhyphen{} For soft restarts, the number of points to move. Default is 3.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.soft.move\_xk}} \sphinxhyphen{} For soft restarts, whether to preserve \(x_k\), or move it to the best new point evaluated. Default is \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.hard.use\_old\_fk}} \sphinxhyphen{} If using hard restarts, whether or not to recycle the objective value at the best iterate found when performing a restart. This saves one objective evaluation. Default is \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.soft.max\_fake\_successful\_steps}} \sphinxhyphen{} The maximum number of successful steps in a given run where the new (smaller) objective value is larger than the best value found in a previous run. Default is \sphinxcode{\sphinxupquote{maxfun}}, the input to \sphinxcode{\sphinxupquote{pybobyqa.solve()}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.auto\_detect}} \sphinxhyphen{} Whether or not to automatically determine when to restart. This is an extra condition, and restarts can still be triggered by small trust region radius, etc. Default is \sphinxcode{\sphinxupquote{True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.auto\_detect.history}} \sphinxhyphen{} How many iterations of data on model changes and trust region radii to store. There are two criteria used: trust region radius decreases (no increases over the history, more decreases than no changes), and change in model Jacobian (consistently increasing trend as measured by slope and correlation coefficient of line of best fit). Default is 30.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.auto\_detect.min\_chg\_model\_slope}} \sphinxhyphen{} Minimum rate of increase of \(\log(\|g_k-g_{k-1}\|)\) and \(\log(\|H_k-H_{k-1}\|_F)\) over the past iterations to cause a restart. Default is 0.015.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{restarts.auto\_detect.min\_correl}} \sphinxhyphen{} Minimum correlation of the data sets \((k, \log(\|g_k-g_{k-1}\|))\) and \((k, \log(\|H_k-H_{k-1}\|_F))\) required to cause a restart. Default is 0.1.

\end{itemize}


\section{General Convex Constraints}
\label{\detokenize{advanced:general-convex-constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{projections.dykstra.d\_tol}} \sphinxhyphen{} termination tolerance for Dykstraâ€™s algorithm for computing the projection onto the intersection of all convex constraints. Default is \(10^{-10}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{projections.dykstra.max\_iters}} \sphinxhyphen{} maximum iterations of Dykstraâ€™s algorithm for computing the projection onto the intersection of all convex constraints. Default is 100.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{projections.feasible\_tol}} \sphinxhyphen{} tolerance for checking feasibility of initial points with respect to general convex constraints. Default is \(10^{-10}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{projections.pgd\_tol}} \sphinxhyphen{} termination tolerance for trust\sphinxhyphen{}region and geometry\sphinxhyphen{}improving subproblems. Default is \(10^{-8}\).

\end{itemize}


\section{References}
\label{\detokenize{advanced:references}}
\sphinxstepscope


\chapter{Diagnostic Information}
\label{\detokenize{diagnostic:diagnostic-information}}\label{\detokenize{diagnostic::doc}}
\sphinxAtStartPar
In {\hyperref[\detokenize{userguide::doc}]{\sphinxcrossref{\DUrole{doc}{Using Py\sphinxhyphen{}BOBYQA}}}}, we saw that the output of Py\sphinxhyphen{}BOBYQA returns a container which includes diagnostic information about the progress of the algorithm (\sphinxcode{\sphinxupquote{soln.diagnostic\_info}}). This object is a \sphinxhref{http://pandas.pydata.org/}{Pandas} DataFrame, with one row per iteration of the algorithm. If Pandas is not available, it returns a dictionary where each key listed below has a list of values, one per iteration of the algorithm. In this section, we explain the meaning of each type of output (the columns of the DataFrame).

\sphinxAtStartPar
To save this information to a CSV file, use:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Previously: define objfun and x0}

\PYG{c+c1}{\PYGZsh{} Turn on diagnostic information}
\PYG{n}{user\PYGZus{}params} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{logging.save\PYGZus{}diagnostic\PYGZus{}info}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{k+kc}{True}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Call Py\PYGZhy{}BOBYQA}
\PYG{n}{soln} \PYG{o}{=} \PYG{n}{pybobyqa}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{objfun}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{user\PYGZus{}params}\PYG{o}{=}\PYG{n}{user\PYGZus{}params}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save diagnostic info to CSV}
\PYG{n}{soln}\PYG{o}{.}\PYG{n}{diagnostic\PYGZus{}info}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myfile.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Depending on exactly how Py\sphinxhyphen{}BOBYQA terminates, the last row of results may not be fully populated.


\section{Current Iterate}
\label{\detokenize{diagnostic:current-iterate}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{xk}} \sphinxhyphen{} Best point found so far (current iterate). This is only saved if \sphinxcode{\sphinxupquote{user\_params{[}\textquotesingle{}logging.save\_xk\textquotesingle{}{]} = True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fk}} \sphinxhyphen{} The value of \(f\) at the current iterate.

\end{itemize}


\section{Trust Region}
\label{\detokenize{diagnostic:trust-region}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rho}} \sphinxhyphen{} The lower bound on the trust region radius \(\rho_k\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{delta}} \sphinxhyphen{} The trust region radius \(\Delta_k\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{norm\_sk}} \sphinxhyphen{} The norm of the trust region step \(\|s_k\|\).

\end{itemize}


\section{Model Interpolation}
\label{\detokenize{diagnostic:model-interpolation}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npt}} \sphinxhyphen{} The number of interpolation points.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolation\_error}} \sphinxhyphen{} The sum of squares of the interpolation errors from the interpolated model.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolation\_condition\_number}} \sphinxhyphen{} The condition number of the matrix in the interpolation linear system.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolation\_change\_g\_norm}} \sphinxhyphen{} The norm of the change in model gradient at this iteration, \(\|g_k-g_{k-1}\|\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{interpolation\_change\_H\_norm}} \sphinxhyphen{} The Frobenius norm of the change in model Hessian at this iteration, \(\|H_k-H_{k-1}\|_F\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{poisedness}} \sphinxhyphen{} The smallest value of \(\Lambda\) for which the current interpolation set \(Y_k\) is \(\Lambda\)\sphinxhyphen{}poised in the current trust region. This is the most expensive piece of information to compute, and is only computed if \sphinxcode{\sphinxupquote{user\_params{[}\textquotesingle{}logging.save\_poisedness\textquotesingle{} = True}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_distance\_xk}} \sphinxhyphen{} The maximum distance from any interpolation point to the current iterate.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{norm\_gk}} \sphinxhyphen{} The norm of the model gradient \(\|g_k\|\).

\end{itemize}


\section{Iteration Count}
\label{\detokenize{diagnostic:iteration-count}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nruns}} \sphinxhyphen{} The number of times the algorithm has been restarted.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nf}} \sphinxhyphen{} The number of objective evaluations so far (see \sphinxcode{\sphinxupquote{soln.nf}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nx}} \sphinxhyphen{} The number of points at which the objective has been evaluated so far (see \sphinxcode{\sphinxupquote{soln.nx}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nsamples}} \sphinxhyphen{} The total number of objective evaluations used for all current interpolation points.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iter\_this\_run}} \sphinxhyphen{} The number of iterations since the last restart.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iters\_total}} \sphinxhyphen{} The total number of iterations so far.

\end{itemize}


\section{Algorithm Progress}
\label{\detokenize{diagnostic:algorithm-progress}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iter\_type}} \sphinxhyphen{} A text description of what type of iteration we had (e.g. Successful, Safety, etc.)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratio}} \sphinxhyphen{} The ratio of actual to predicted objective reduction in the trust region step.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{slow\_iter}} \sphinxhyphen{} Equal to 1 if the current iteration is successful but slow, 0 if is successful but not slow, and \sphinxhyphen{}1 if was not successful.

\end{itemize}

\sphinxstepscope


\chapter{Version History}
\label{\detokenize{history:version-history}}\label{\detokenize{history::doc}}
\sphinxAtStartPar
This section lists the different versions of Py\sphinxhyphen{}BOBYQA and the updates between them.


\section{Version 1.0 (6 Feb 2018)}
\label{\detokenize{history:version-1-0-6-feb-2018}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Initial release of Py\sphinxhyphen{}BOBYQA

\end{itemize}


\section{Version 1.0.1 (20 Feb 2018)}
\label{\detokenize{history:version-1-0-1-20-feb-2018}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Minor bug fix to trust region subproblem solver (the output \sphinxcode{\sphinxupquote{crvmin}} is calculated correctly) \sphinxhyphen{} this has minimal impact on the performance of Py\sphinxhyphen{}BOBYQA.

\end{itemize}


\section{Version 1.0.2 (20 Jun 2018)}
\label{\detokenize{history:version-1-0-2-20-jun-2018}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Extra optional input \sphinxcode{\sphinxupquote{args}} which passes through arguments for \sphinxcode{\sphinxupquote{objfun}} (pull request from \sphinxhref{https://github.com/logangrado}{logangrado}).

\item {} 
\sphinxAtStartPar
Bug fixes: default parameters for reduced initialization cost regime, returning correct value from safety steps, retrieving dependencies during installation.

\end{itemize}


\section{Version 1.1 (24 Dec 2018)}
\label{\detokenize{history:version-1-1-24-dec-2018}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Extra parameters to control the trust region radius over multiple restarts, designed for global optimization.

\item {} 
\sphinxAtStartPar
New input flag \sphinxcode{\sphinxupquote{seek\_global\_minimum}} to set sensible default parameters for global optimization. New example script to demonstrate this functionality.

\item {} 
\sphinxAtStartPar
Bug fix: default trust region radius when scaling variables within bounds.

\end{itemize}

\sphinxAtStartPar
Initially released as version 1.1a0 on 17 Jul 2018.


\section{Version 1.1.1 (5 Apr 2019)}
\label{\detokenize{history:version-1-1-1-5-apr-2019}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Link code to Zenodo, to create DOI \sphinxhyphen{} no changes to the Py\sphinxhyphen{}BOBYQA algorithm.

\end{itemize}


\section{Version 1.2 (25 Feb 2020)}
\label{\detokenize{history:version-1-2-25-feb-2020}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Use deterministic initialisation by default (so it is no longer necessary to set a random seed for reproducibility of Py\sphinxhyphen{}BOBYQA results).

\item {} 
\sphinxAtStartPar
Full model Hessian stored rather than just upper triangular part \sphinxhyphen{} this improves the runtime of Hessian\sphinxhyphen{}based operations.

\item {} 
\sphinxAtStartPar
Faster trust\sphinxhyphen{}region and geometry subproblem solutions in Fortran using the \sphinxhref{https://github.com/lindonroberts/trust-region}{trustregion} package.

\item {} 
\sphinxAtStartPar
Donâ€™t adjust starting point if it is close to the bounds (as long as it is feasible).

\item {} 
\sphinxAtStartPar
Option to stop default logging behavior and/or enable per\sphinxhyphen{}iteration printing.

\item {} 
\sphinxAtStartPar
Bugfix: correctly handle 1\sphinxhyphen{}sided bounds as inputs, avoid divide\sphinxhyphen{}by\sphinxhyphen{}zero warnings when auto\sphinxhyphen{}detecting restarts.

\end{itemize}


\section{Version 1.3 (14 Apr 2021)}
\label{\detokenize{history:version-1-3-14-apr-2021}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Remove NumPy deprecation warnings from use of np.int and np.float

\end{itemize}


\section{Version 1.4 (16 May 2023)}
\label{\detokenize{history:version-1-4-16-may-2023}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Return diagnostic information as dictionary if Pandas not available (removes Pandas dependency)

\item {} 
\sphinxAtStartPar
Handle Nan/Inf values in model gradient and Hessian by gracefully exiting trust\sphinxhyphen{}region subproblem

\item {} 
\sphinxAtStartPar
Bugfix: automatically make model Hessian symmetric before trust\sphinxhyphen{}region subproblem with warning, instead of returning an error

\item {} 
\sphinxAtStartPar
Bugfix: reset slow iteration counter when doing soft restarts

\end{itemize}


\section{Version 1.4.1 (11 Apr 2024)}
\label{\detokenize{history:version-1-4-1-11-apr-2024}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Migrate package setup to pyproject.toml (required for Python version 3.12)

\item {} 
\sphinxAtStartPar
Drop support for Python 2.7 and \textless{}=3.7 due to new setup process

\end{itemize}


\section{Version 1.5.0 (16 Sep 2024)}
\label{\detokenize{history:version-1-5-0-16-sep-2024}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Added support for general convex constraints

\end{itemize}


\chapter{Acknowledgements}
\label{\detokenize{index:acknowledgements}}
\sphinxAtStartPar
This software was initially developed under the supervision of \sphinxhref{https://www.maths.ox.ac.uk/people/coralia.cartis}{Coralia Cartis}, and was supported by the EPSRC Centre For Doctoral Training in \sphinxhref{https://www.maths.ox.ac.uk/study-here/postgraduate-study/industrially-focused-mathematical-modelling-epsrc-cdt}{Industrially Focused Mathematical Modelling} (EP/L015803/1) in collaboration with the \sphinxhref{http://www.nag.com/}{Numerical Algorithms Group}.
Development of Py\sphinxhyphen{}BOBYQA has also been supported by the Australian Research Council (DE240100006).

\begin{sphinxthebibliography}{Powell20}
\bibitem[CFMR2018]{info:cfmr2018}
\sphinxAtStartPar
Coralia Cartis, Jan Fiala, Benjamin Marteau and Lindon Roberts, \sphinxhref{https://doi.org/10.1145/3338517}{Improving the Flexibility and Robustness of Model\sphinxhyphen{}Based Derivative\sphinxhyphen{}Free Optimization Solvers}, \sphinxstyleemphasis{ACM Transactions on Mathematical Software}, 45:3 (2019), pp. 32:1\sphinxhyphen{}32:41 {[}\sphinxhref{https://arxiv.org/abs/1804.00154}{preprint}{]}
\bibitem[Powell2009]{info:powell2009}
\sphinxAtStartPar
Michael J. D. Powell, \sphinxhref{http://www.damtp.cam.ac.uk/user/na/NA\_papers/NA2009\_06.pdf}{The BOBYQA algorithm for bound constrained optimization without derivatives}, technical report DAMTP 2009/NA06, University of Cambridge, (2009).
\bibitem[CFMR2018]{userguide:cfmr2018}
\sphinxAtStartPar
Coralia Cartis, Jan Fiala, Benjamin Marteau and Lindon Roberts, \sphinxhref{https://doi.org/10.1145/3338517}{Improving the Flexibility and Robustness of Model\sphinxhyphen{}Based Derivative\sphinxhyphen{}Free Optimization Solvers}, \sphinxstyleemphasis{ACM Transactions on Mathematical Software}, 45:3 (2019), pp. 32:1\sphinxhyphen{}32:41 {[}\sphinxhref{https://arxiv.org/abs/1804.00154}{preprint}{]}
\bibitem[CRO2022]{userguide:cro2022}
\sphinxAtStartPar
Coralia Cartis, Lindon Roberts and Oliver Sheridan\sphinxhyphen{}Methven, \sphinxhref{https://doi.org/10.1080/02331934.2021.1883015}{Escaping local minima with derivative\sphinxhyphen{}free methods: a numerical investigation}, \sphinxstyleemphasis{Optimization}, 71:8 (2022), pp. 2343\sphinxhyphen{}2373. {[}\sphinxhref{https://arxiv.org/abs/1812.11343}{arXiv preprint: 1812.11343}{]}
\bibitem[R2024]{userguide:r2024}
\sphinxAtStartPar
Lindon Roberts, \sphinxhref{https://arxiv.org/abs/2403.14960}{Model Construction for Convex\sphinxhyphen{}Constrained Derivative\sphinxhyphen{}Free Optimization}, \sphinxstyleemphasis{arXiv preprint arXiv:2403.14960} (2024).
\bibitem[B2017]{userguide:b2017}
\sphinxAtStartPar
Amir Beck, \sphinxhref{https://doi.org/10.1137/1.9781611974997}{First\sphinxhyphen{}Order Methods in Optimization}, SIAM (2017).
\bibitem[CFMR2018]{advanced:cfmr2018}
\sphinxAtStartPar
Coralia Cartis, Jan Fiala, Benjamin Marteau and Lindon Roberts, \sphinxhref{https://doi.org/10.1145/3338517}{Improving the Flexibility and Robustness of Model\sphinxhyphen{}Based Derivative\sphinxhyphen{}Free Optimization Solvers}, \sphinxstyleemphasis{ACM Transactions on Mathematical Software}, 45:3 (2019), pp. 32:1\sphinxhyphen{}32:41 {[}\sphinxhref{https://arxiv.org/abs/1804.00154}{preprint}{]}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}